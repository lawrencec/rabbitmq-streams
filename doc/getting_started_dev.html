<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>Getting Started with Feedshub</title>
<meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2009-05-22 Fri"/>
<meta name="author" content="LShift Inc"/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color:lightblue; font-weight:normal }
  .target { }
  .timestamp { color: grey }
  .timestamp-kwd { color: CadetBlue }
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="stylesheet.css" />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*/-->
</script>
</head><body>
<h1 class="title">Getting Started with Feedshub</h1>



<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 Getting started with Feedshub </a>
<ul>
<li><a href="#sec-1.1">1.1 General Overview </a></li>
<li><a href="#sec-1.2">1.2 Installation </a></li>
<li><a href="#sec-1.3">1.3 Running and debugging </a></li>
<li><a href="#sec-1.4">1.4 Developing </a>
<ul>
<li><a href="#sec-1.4.1">1.4.1 Plugins </a>
<ul>
<li><a href="#sec-1.4.1.1">1.4.1.1 <code>plugin.js</code> </a>
<ul>
<li><a href="#sec-1.4.1.1.1">1.4.1.1.1 The lifecycle of a plugin </a></li>
<li><a href="#sec-1.4.1.1.2">1.4.1.1.2 Plugin configuration </a></li>
</ul>
</li>
<li><a href="#sec-1.4.1.2">1.4.1.2 Writing Sinks/Sources (<code>Servers</code>) </a></li>
<li><a href="#sec-1.4.1.3">1.4.1.3 Writing <code>PipelineComponents</code> </a></li>
</ul>
</li>
<li><a href="#sec-1.4.2">1.4.2 Writing Harnesses to add plugin support for new languages </a>
<ul>
<li><a href="#sec-1.4.2.1">1.4.2.1 Harness invocation </a></li>
<li><a href="#sec-1.4.2.2">1.4.2.2 Harness services </a>
<ul>
<li><a href="#sec-1.4.2.2.1">1.4.2.2.1 Instance configuration </a></li>
<li><a href="#sec-1.4.2.2.2">1.4.2.2.2 Channels </a>
<ul>
<li><a href="#sec-1.4.2.2.2.1">1.4.2.2.2.1 Notifcation Channel </a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-1.4.2.3">1.4.2.3 State </a></li>
<li><a href="#sec-1.4.2.4">1.4.2.4 Storage </a></li>
</ul>
</li>
<li><a href="#sec-1.4.3">1.4.3 The Architecture in more detail </a></li>
</ul>
</li>
<li><a href="#sec-1.5">1.5 Administration </a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1">1 Getting started with Feedshub </h2>
<div id="text-1">


</div>

<div id="outline-container-1.1" class="outline-3">
<h3 id="sec-1.1">1.1 General Overview </h3>
<div id="text-1.1">


<p>
Feedshub is a stream based-architecture conceived to bring order and
manageability to the BBC's massive and increasingly unwieldy feed
infrastructre.
</p>
<p>
However the framework is very general and not limited to working with
Atom/RSS/&hellip; Feeds (for example binary data can be handled efficiently as
well). In a way you could think of Feedshub as a distributed, robust,
scalable, secure, user-friendly and manageable version of Unix pipes (you can
find more background and updates on the <a href="http://www.lshift.net/blog/tag/feedshub">LShift blog</a>).
//The
The basic logical building blocks are <i>Sources</i> and <i>Sinks</i> (<code>Servers</code>) of
data and <i>Feeds</i> (NB: Feed in this sense has nothing to do with RSS/Atom/etc.;
<i>Processing Pipeline</i> would be more accurate description) composed of
<code>PipelineComponents</code> which can route (e.g. based on regexp matches on Atom
feed entries) merge and transform the data in arbitrary ways (e.g. by applying
xslt transforms), as depicted below:
</p>

<div id="fig:flow-simplified" class="figure">
<p><img src="./flow-simplified.png"  alt="./flow-simplified.png" /></p>
<p>Flow of Information in Feedshub (simplified excerpt).</p>
</div>

<p>
<code>Servers</code> as well as <code>PipelineComponents</code> (jointly referred to as <code>Plugins</code>)
can currently be written in Java, Python and Ruby (<b>FIXME</b> really?) and
require almost no boilerplate (see e.g. <a href="../plugins/regexp_replace/regexp_replace.py">regexp_replace.py</a>) Support for other
languages can be added straightforwardly by creating an appropriate <code>Harness</code>.
</p>
<p>
Robustness, scalability etc. are achieved through the "plumbing" layer which
is transparent to Plugin authors and (mostly) consists of the
Feedshub-specific <code>Orchestrator</code> (which takes care setting up all the wiring
between components) as well as two proven off-the-shelf <a href="http://www.rabbitmq.com">RabbitMQ</a> (the
messaging broker which provides high-performance, fault-tolerant queued
communication between components) and Apache's <a href="http://couchdb.apache.org/">CouchDB</a> (which
provides a store for configuration and persistent state for <code>Plugins</code> which
require it)<sup><a class="footref" name="fnr.1" href="#fn.1">1</a></sup>. (<b>FIXME</b> Erlang Blurp; e.g. supervisors)
</p>
</div>

</div>

<div id="outline-container-1.2" class="outline-3">
<h3 id="sec-1.2">1.2 Installation </h3>
<div id="text-1.2">


<ol>
<li>
Install the runtime dependencies:



<pre class="src src-sh">
make setup
</pre>




<p>
This will attempt to download and install all required dependencies. At the
minute it assumes you are using a Linux distribution with `apt-get`; but
this is restricted to a small, easily replicated section of build
dependencies (the targets ending in <code>-debs</code>). Currently a couple of packages
(e.g. CouchDB and RabbitMQ) will be locally installed from sources in the
Feedshub directory, but in the future Feedshub will likely offer more
flexibility in this regard; just be aware of possible conflicts with
system-wide installs.
</p>
</li>
<li>
Build everything:



<pre class="src src-sh">
make all
</pre>




</li>
</ol>
</div>

</div>

<div id="outline-container-1.3" class="outline-3">
<h3 id="sec-1.3">1.3 Running and debugging </h3>
<div id="text-1.3">


<p>
There are three components which need to be running: RabbitMQ , CouchDB (the
database used for configuration and per-component state), and the
Orchestrator. RabbitMQ and CouchDB are together referred to as the "core" and
must be started before the Orchestrator. The following is currently our
preferred means to get everything up and running (Note: as the project matures
this will become less fiddly and delicate, but for the moment make sure you
follow the instructions exactly):
</p>
<ol>
<li>
Start up three xterms which are configured to listen to the outputs of
each component
(<font color="#400000"><b>rabbitMQ</b></font> </font>,
<font color="#004000"><b>couchDB</b></font> </font>,
<font color="#000040"><b>orchestrator</b></font>)

<pre class="src src-sh">
make listen_all
</pre>




</li>
<li>
Stop all the components (this doesn't hurt if they're not already running),
clean the CouchDB and RabbitMQ broker, set them back up, install the test
configuration and get everthing up and running:



<pre class="src src-sh">
make stop_all_nox all cleandb start_core_nox &amp;&amp; sleep 2 <span style="color: #ff9ddd;">\</span>
&amp;&amp; ./setup-core.sh &amp;&amp; sleep 1 &amp;&amp; make start_orchestrator_nox <span style="color: #ff9ddd;">\</span>
&amp;&amp; sleep 5 &amp;&amp; python sbin/install_test_data.py <span style="color: #ff9ddd;">\</span>
&amp;&amp; make start_orchestrator_nox
</pre>




<p>
Note that if you already got a system install of couchDB or RabbitMQ etc.
you should make sure that they are either currently not running or using
different ports than the local versions that feedshub installs.
</p>
</li>
</ol>

<p>In general, <code>Makefile</code> targets that end in <code>_nox</code> (<i>No X</i>) will not
start new xterms.
</p>
<p>
All three components are normal Erlang shells (though due to
forwarding outputs over <code>nc</code>, the command history features are
lost). Thus to quit any of the components, enter <code>q()</code> and press
return in the shells. The Makefile targets take care of stopping the
components as necessary.
</p>
</div>

</div>

<div id="outline-container-1.4" class="outline-3">
<h3 id="sec-1.4">1.4 Developing </h3>
<div id="text-1.4">


</div>

<div id="outline-container-1.4.1" class="outline-4">
<h4 id="sec-1.4.1">1.4.1 Plugins </h4>
<div id="text-1.4.1">


</div>

<div id="outline-container-1.4.1.1" class="outline-5">
<h5 id="sec-1.4.1.1">1.4.1.1 <code>plugin.js</code> </h5>
<div id="text-1.4.1.1">




<pre class="src src-javascript">
<span style="color: #a3a3ff;">// </span><span style="color: #a3a3ff;">applies to both pipeline components and servers
</span>{ <span style="color: #ff9ddd;">"name"</span>: <span style="color: #ff9ddd;">"Some Plugin description"</span>,
  <span style="color: #ff9ddd;">"author"</span>: { <span style="color: #ff9ddd;">"name"</span>:  <span style="color: #ff9ddd;">"John Doe"</span>,
              <span style="color: #ff9ddd;">"email"</span>: <span style="color: #ff9ddd;">"jondoe@example.tld"</span> },
  <span style="color: #ff9ddd;">"type"</span>: <span style="color: #ff9ddd;">"plugin-specification"</span>,
  <span style="color: #ff9ddd;">"harness"</span>: <span style="color: #ff9ddd;">"java"</span>, <span style="color: #a3a3ff;">// </span><span style="color: #a3a3ff;">or "python" or "ruby"
</span>  <span style="color: #ff9ddd;">"subtype"</span>: <span style="color: #ff9ddd;">"pipeline_component"</span>, <span style="color: #a3a3ff;">// </span><span style="color: #a3a3ff;">or  "server"
</span>  <span style="color: #ff9ddd;">"global_configuration_specification"</span>: [], <span style="color: #a3a3ff;">// </span><span style="color: #a3a3ff;">experimental, might disappear
</span>  <span style="color: #a3a3ff;">/* </span><span style="color: #a3a3ff;">the configuration that must be provided per plugin instance */</span>
  <span style="color: #ff9ddd;">"configuration_specification"</span>:  [ { <span style="color: #ff9ddd;">"name"</span>: <span style="color: #ff9ddd;">"port"</span>, <span style="color: #ff9ddd;">"label"</span>: <span style="color: #ff9ddd;">"Port"</span>, <span style="color: #ff9ddd;">"type"</span>: <span style="color: #ff9ddd;">"Nat"</span> }
                                    <span style="color: #a3a3ff;">// </span><span style="color: #a3a3ff;">...
</span>                                  ],
  <span style="color: #a3a3ff;">/* </span><span style="color: #a3a3ff;">configuration per terminal (terminal ONLY) */</span>
  <span style="color: #ff9ddd;">"destination_specification"</span>: [ { <span style="color: #ff9ddd;">"name"</span>: <span style="color: #ff9ddd;">"title"</span>, <span style="color: #ff9ddd;">"label"</span>: <span style="color: #ff9ddd;">"Title for RSS"</span>, <span style="color: #ff9ddd;">"type"</span>: <span style="color: #ff9ddd;">"String"</span> }
                                 <span style="color: #a3a3ff;">// </span><span style="color: #a3a3ff;">...
</span>                               ],
  <span style="color: #a3a3ff;">/* </span><span style="color: #a3a3ff;">configuration per terminal (terminal ONLY) */</span>
  <span style="color: #ff9ddd;">"source_specification"</span>: [ { <span style="color: #ff9ddd;">"name"</span>: <span style="color: #ff9ddd;">"url"</span>, <span style="color: #ff9ddd;">"label"</span>: <span style="color: #ff9ddd;">"URL of RSS"</span>, <span style="color: #ff9ddd;">"type"</span>: <span style="color: #ff9ddd;">"URL"</span> }
                            <span style="color: #a3a3ff;">// </span><span style="color: #a3a3ff;">...
</span>                          ],

  <span style="color: #a3a3ff;">/* </span><span style="color: #a3a3ff;">configuration per feed component (feed_component ONLY) */</span>
  <span style="color: #ff9ddd;">"inputs_specification"</span>: [ { <span style="color: #ff9ddd;">"name"</span>: <span style="color: #ff9ddd;">"input"</span> }
                            <span style="color: #a3a3ff;">// </span><span style="color: #a3a3ff;">...
</span>                          ],
  <span style="color: #a3a3ff;">/* </span><span style="color: #a3a3ff;">configuration per feed component (feed_component ONLY) */</span>
  <span style="color: #ff9ddd;">"outputs_specification"</span>: [ { <span style="color: #ff9ddd;">"name"</span>: <span style="color: #ff9ddd;">"output"</span> }
                           <span style="color: #a3a3ff;">//</span><span style="color: #a3a3ff;">...
</span>                           ],
   <span style="color: #a3a3ff;">/* </span><span style="color: #a3a3ff;">AWMS: again what's the point of this? Shouldn't this just be a bool? */</span>
  <span style="color: #ff9ddd;">"database_specification"</span>: <span style="font-weight: bold;">null</span> <span style="color: #a3a3ff;">// </span><span style="color: #a3a3ff;">or {}  initial values for the per instance db
</span>}
</pre>





</div>

<div id="outline-container-1.4.1.1.1" class="outline-6">
<h6 id="sec-1.4.1.1.1">1.4.1.1.1 The lifecycle of a plugin </h6>
<div id="text-1.4.1.1.1">

<ol>
<li>
The plugin configuration is read from stdin in json format.
</li>
<li>
The plugin prints its PID to stdout (so that runaway plugins can be
killed easily by the orchestrator).
</li>
<li>
The plugin initializes itself.
</li>
<li>
A worker thread or process is spawned by the main thread of the
plugin (this, or its children, will do the actual work).
</li>
<li>
The main thread blocks on reading stdout. As soon as stdout is closed
by the orchestrator the plugin kills itself and all spawned threads
or processes (this is the shutdown protocol; misbehaving plugins that
fail to shutdown if requested will be killed by sending a TERM signal
(verify) to the PID obtained in step 2).
</li>
</ol>
</div>

</div>

<div id="outline-container-1.4.1.1.2" class="outline-6">
<h6 id="sec-1.4.1.1.2">1.4.1.1.2 Plugin configuration </h6>
<div id="text-1.4.1.1.2">

<pre class="example">
"configuration_specification": [
      {"label": "Regexp",
       "type": "string",
       "name": "regexp"
      },
</pre>
*********

</div>
</div>

</div>

<div id="outline-container-1.4.1.2" class="outline-5">
<h5 id="sec-1.4.1.2">1.4.1.2 Writing Sinks/Sources (<code>Servers</code>) </h5>
<div id="text-1.4.1.2">

</div>

</div>

<div id="outline-container-1.4.1.3" class="outline-5">
<h5 id="sec-1.4.1.3">1.4.1.3 Writing <code>PipelineComponents</code> </h5>
<div id="text-1.4.1.3">

</div>
</div>

</div>

<div id="outline-container-1.4.2" class="outline-4">
<h4 id="sec-1.4.2">1.4.2 Writing Harnesses to add plugin support for new languages </h4>
<div id="text-1.4.2">

<p>Each environment (e.g., Java, Python) in which plugins run needs a
harness.  Minimally, this is simply a shell script that starts a
plugin process given a plugin name.
</p>
<p>
The harness also provides some abstraction of the services needed by
plugins; e.g., hooking up communications channels, storing documents.
This abstraction &ndash; a base class, say &ndash; encapsulates the conventions
for how plugins are initialised, communicated with, and so on, letting
the plugin developer be concerned only with the specific task of the
plugin.
</p>
<p>
The set of harness and plugin conventions is currently a moving
target; however, in general, the Python and Java harnesses (and this
document) will be kept up-to-date.
</p>

</div>

<div id="outline-container-1.4.2.1" class="outline-5">
<h5 id="sec-1.4.2.1">1.4.2.1 Harness invocation </h5>
<div id="text-1.4.2.1">


<p>
The type of the harness is indicated by the plugin descriptor
<code>plugin.js</code> in the plugin directory.  The name is treated as a
directory under <code>harness/</code>, and the file <code>run_plugin.sh</code> in that
directory is invoked.  The plugin configuration is then printed, as
JSON, to that process's <code>stdin</code>. For example, the file
<code>plugins/xslt/plugin.js</code> specifies the name of the harness as <code>java</code>
and so that plugin will be launched by the <code>Orchestrator</code> calling
<code>run_plugin.sh</code> in the directory <code>harness/java</code>.
</p>
<p>
The harness, then, must <i>at least</i> read the configuration, extract the
plugin name (and use it as a directory under <code>plugins/</code>), and run the
plugin code, supplying the configuration in an appropriate form.  It
may also need to set environment variables, load modules, and so on.
</p>
<p>
Each harness will have its own convention for how to run a plugin
given its name.  For example, the Python harness treats the plugin
name as the directory **and** as a module name, under which it (by
convention) expects to find a callable named <code>run</code>, which it invokes
with the arguments as a dictionary.  It also puts the harness
directory on the <code>PYTHON_PATH</code> so that the plugin base class can be
imported, as well as <code>lib/</code> in the plugin directory; and, it changes
the working directory to the plugin directory so that resources can be
loaded relative to that directory.
</p>
<p>
One of the first things that a harness must do, is to print out its
<i>PID</i> on <code>STDOUT</code>. This is picked up by the orchestrator, and used to
kill the plugin, should it be necessary to do so. Some programming
languages make it tricky to get hold of the <i>PID</i> and as a result, we
ask the shell script, <code>run_plugin.sh</code> to supply the <i>PID</i> as an
argument to the plugin harness. For example, the file
<code>harness/java/run_plugin.sh</code> contains:
</p>
<pre class="example">
exec java -cp feedshub_harness.jar net.lshift.feedshub.harness.Run $$
</pre>

<p>
After the harness has printed out its <i>PID</i>, it should continue with
the startup of the plugin itself. It should also create a thread that
sits, blocking on its <code>STDIN</code> file descriptor, and as soon as that
file descriptor has been closed, the harness should terminate. This is
the preferred means through which the Orchestrator stops plugins.
</p>
</div>

</div>

<div id="outline-container-1.4.2.2" class="outline-5">
<h5 id="sec-1.4.2.2">1.4.2.2 Harness services </h5>
<div id="text-1.4.2.2">


<p>
The harness also provides convenience APIs for interacting with the
system. In principle, following the invocation convention &ndash; e.g., for
Python, providing a correctly-named module with a run(args) procedure
&ndash; is enough. But many details of the configuration can be taken care
of for the plugin developer.
</p>

</div>

<div id="outline-container-1.4.2.2.1" class="outline-6">
<h6 id="sec-1.4.2.2.1">1.4.2.2.1 Instance configuration </h6>
<div id="text-1.4.2.2.1">


<p>
An instance of the plugin may have configuration specific to that
instance. (This is due to be tidied up)
</p>
<p>
This is supplied by the orchestrator, and should be exposed
read-only to the plugin code.
</p>
</div>

</div>

<div id="outline-container-1.4.2.2.2" class="outline-6">
<h6 id="sec-1.4.2.2.2">1.4.2.2.2 Channels </h6>
<div id="text-1.4.2.2.2">


<p>
The plugin descriptor, <code>plugin.js</code>, specifies named input and output
channels required by an instance of the plugin. E.g.,
</p>
<p>
&hellip;
"inputs": [{"name": "in"}],
"outputs": [{"name": "result"}],
&hellip;
</p>
<p>
The orchestrator constructs input channels as AMQP queues, and output
channels as AMQP exchanges. The names of these queues and exchanges
are supplied as part of the initialisation configuration; e.g.,
</p>
<p>
&hellip;
"inputs" : ["transformer_in"],
"outputs" :["transformer_result]
&hellip;
</p>
<p>
Note that the queue and exchange names will in general be arbitrary,
and that they are supplied in an ordered list.  The harness must refer
to the plugin descriptor to match the queue or exchange to the named
channel. One way to think of this is that the <code>plugin.js</code> file
specifies the type, or class of the available connections to and from
the plugin, and the initialisation configuration contains instances of
these types or classes.
</p>
<p>
Giving the plugin programmer access to the channels in a convenient
way will depend on the capabilities of the environment. The Python
harness lets the plugin developer supply a maps of channel names to
method names; input channels use the named method as a callback, and
output channels are inserted into the object as methods. The Java
harness similarly uses reflection to attach <code>Publisher</code> objects to the
plugin's fields for outputs, and dynamically looks up inputs, where
the field names are the names of the channels given in the <code>plugin.js</code>
specification.
</p>

</div>

<div id="outline-container-1.4.2.2.2.1" class="outline-7">
<h7 id="sec-1.4.2.2.2.1">1.4.2.2.2.1 Notifcation Channel </h7>
<div id="text-1.4.2.2.2.1">


<p>
Because the <code>STDOUT</code> file descriptor of the plugin is captured by the
Orchestrator, it is not recommended to output text or debugging
information though simply printing messages out. Instead, an
independent notification exchange is provided to which messages can be
sent. This exchange is called <code>feedshub/log</code> and is not supplied in
the initialisation configuration. This is a topic exchange, and so the
messages must have a routing key. The routing key should be
<code>loglevel.feedID.pluginName.nodeID</code> where loglevel is one of <code>debug</code>,
<code>info</code>, <code>warn</code>, <code>error</code>, <code>fatal</code>, and the three other components take
the values supplied in the corresponding fields in the initialisation
configuration. By using this scheme, it (currently potentially) allows
the orchestrator to filter and select messages.
</p>
<p>
The harness should try and present a suitable API to the plugin such
that the plugin has the ability to send such informational
messages. Both the Python and Java harnesses have methods for each of
the five different log levels, filling in the other components of
routing key automatically, and including any message supplied.
</p>
<p>
Additionally, the harness should try and catch any errors that the
plugin produces, sending such messages out on this exchange. Messages
should be marked with <code>delivery mode</code> 2 (or <i>persistent</i>) to make sure
messages are not lost. We recommend using a separate AMQP channel for
this exchange so that if you wish to treat messages sent by the plugin
in its normal course of operation as transactional, then this does not
force notification messages to also become transactional.
</p>
</div>
</div>
</div>

</div>

<div id="outline-container-1.4.2.3" class="outline-5">
<h5 id="sec-1.4.2.3">1.4.2.3 State </h5>
<div id="text-1.4.2.3">


<p>
A plugin instance gets a document in which to store its running
state. This state will persist over restarts, and will be visible to
management interfaces. It should be exposed as read-write.
</p>
<p>
TODO Avoiding conflicts &ndash; maybe the state is the argument and result
of any callback (and these are serialised)?
</p>
</div>

</div>

<div id="outline-container-1.4.2.4" class="outline-5">
<h5 id="sec-1.4.2.4">1.4.2.4 Storage </h5>
<div id="text-1.4.2.4">


<p>
The plugin descriptor can also specify a storage database private to
each instance. The orchestrator provides the name of this database in
the initialisation configuration.
</p>
<p>
TODO safe ways of exposing this to the plugin developer.
</p>
</div>
</div>

</div>

<div id="outline-container-1.4.3" class="outline-4">
<h4 id="sec-1.4.3">1.4.3 The Architecture in more detail </h4>
<div id="text-1.4.3">


<div id="fig:flow-simplified" class="figure">
<p><img src="./flow.png"  alt="./flow.png" /></p>
<p>Information flow (the /almost/ full picture)</p>
</div>

</div>
</div>

</div>

<div id="outline-container-1.5" class="outline-3">
<h3 id="sec-1.5">1.5 Administration </h3>
<div id="text-1.5">





</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn.1" href="#fnr.1">1</a></sup> <b>FIXME</b> the aim is to just provide abstract interfaces to generic
database and messaging services to <code>Plugin</code> writers but this isn't fully the
case presently.
</p>
</div>
</div>
<div id="postamble"><p class="author"> Author: LShift Inc
<a href="mailto:alexander@lshift.net">&lt;alexander@lshift.net&gt;</a>
</p>
<p class="date"> Date: 2009-05-22 Fri</p>
<p>HTML generated by org-mode 6.21b in emacs 23</p>
</div></body>
</html>
